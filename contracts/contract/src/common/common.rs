// Generated by Molecule 0.8.0

use molecule :: prelude :: * ;
# [derive (Clone)] pub struct Uint8 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint8 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint8 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint8 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Uint8 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint8 :: new_unchecked (v) } } impl Uint8 { const DEFAULT_VALUE : [u8 ; 1] = [0 ,] ; pub const TOTAL_SIZE : usize = 1 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 1 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Uint8Reader < 'r > { Uint8Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint8 { type Builder = Uint8Builder ; const NAME : & 'static str = "Uint8" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint8 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint8Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint8Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () ,]) } }
# [derive (Clone , Copy)] pub struct Uint8Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint8Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint8Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint8Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Uint8Reader < 'r > { pub const TOTAL_SIZE : usize = 1 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 1 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint8Reader < 'r > { type Entity = Uint8 ; const NAME : & 'static str = "Uint8Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint8Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Uint8Builder (pub (crate) [Byte ; 1]) ; impl :: core :: fmt :: Debug for Uint8Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Uint8Builder { fn default () -> Self { Uint8Builder ([Byte :: default () ,]) } } impl Uint8Builder { pub const TOTAL_SIZE : usize = 1 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 1 ; pub fn set (mut self , v : [Byte ; 1]) -> Self { self . 0 = v ; self } pub fn nth0 (mut self , v : Byte) -> Self { self . 0 [0] = v ; self } } impl molecule :: prelude :: Builder for Uint8Builder { type Entity = Uint8 ; const NAME : & 'static str = "Uint8Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint8 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 1usize] > for Uint8 { fn from (value : [Byte ; 1usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Uint8 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 1usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Uint8 > for [Byte ; 1usize] { # [track_caller] fn from (value : Uint8) -> Self { [value . nth0 () ,] } } impl From < [u8 ; 1usize] > for Uint8 { fn from (value : [u8 ; 1usize]) -> Self { Uint8Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Uint8 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 1usize] > :: try_from (value) ? . into ()) } } impl From < Uint8 > for [u8 ; 1usize] { # [track_caller] fn from (value : Uint8) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Uint8Reader < 'a >> for & 'a [u8 ; 1usize] { # [track_caller] fn from (value : Uint8Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Uint8Reader < 'a >> for & 'a [u8 ; 1usize] { # [track_caller] fn from (value : & 'a Uint8Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct Uint32 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Uint32 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint32 :: new_unchecked (v) } } impl Uint32 { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 4 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 4 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Uint32Reader < 'r > { Uint32Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint32 { type Builder = Uint32Builder ; const NAME : & 'static str = "Uint32" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint32 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint32Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint32Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () ,]) } }
# [derive (Clone , Copy)] pub struct Uint32Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Uint32Reader < 'r > { pub const TOTAL_SIZE : usize = 4 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 4 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint32Reader < 'r > { type Entity = Uint32 ; const NAME : & 'static str = "Uint32Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint32Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Uint32Builder (pub (crate) [Byte ; 4]) ; impl :: core :: fmt :: Debug for Uint32Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Uint32Builder { fn default () -> Self { Uint32Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl Uint32Builder { pub const TOTAL_SIZE : usize = 4 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 4 ; pub fn set (mut self , v : [Byte ; 4]) -> Self { self . 0 = v ; self } pub fn nth0 (mut self , v : Byte) -> Self { self . 0 [0] = v ; self } pub fn nth1 (mut self , v : Byte) -> Self { self . 0 [1] = v ; self } pub fn nth2 (mut self , v : Byte) -> Self { self . 0 [2] = v ; self } pub fn nth3 (mut self , v : Byte) -> Self { self . 0 [3] = v ; self } } impl molecule :: prelude :: Builder for Uint32Builder { type Entity = Uint32 ; const NAME : & 'static str = "Uint32Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint32 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 4usize] > for Uint32 { fn from (value : [Byte ; 4usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Uint32 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 4usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Uint32 > for [Byte ; 4usize] { # [track_caller] fn from (value : Uint32) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () ,] } } impl From < [u8 ; 4usize] > for Uint32 { fn from (value : [u8 ; 4usize]) -> Self { Uint32Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Uint32 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 4usize] > :: try_from (value) ? . into ()) } } impl From < Uint32 > for [u8 ; 4usize] { # [track_caller] fn from (value : Uint32) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Uint32Reader < 'a >> for & 'a [u8 ; 4usize] { # [track_caller] fn from (value : Uint32Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Uint32Reader < 'a >> for & 'a [u8 ; 4usize] { # [track_caller] fn from (value : & 'a Uint32Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct Uint64 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint64 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint64 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint64 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Uint64 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint64 :: new_unchecked (v) } } impl Uint64 { const DEFAULT_VALUE : [u8 ; 8] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 8 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 8 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Uint64Reader < 'r > { Uint64Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint64 { type Builder = Uint64Builder ; const NAME : & 'static str = "Uint64" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint64 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint64Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint64Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () ,]) } }
# [derive (Clone , Copy)] pub struct Uint64Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint64Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint64Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint64Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Uint64Reader < 'r > { pub const TOTAL_SIZE : usize = 8 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 8 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint64Reader < 'r > { type Entity = Uint64 ; const NAME : & 'static str = "Uint64Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint64Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Uint64Builder (pub (crate) [Byte ; 8]) ; impl :: core :: fmt :: Debug for Uint64Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Uint64Builder { fn default () -> Self { Uint64Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl Uint64Builder { pub const TOTAL_SIZE : usize = 8 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 8 ; pub fn set (mut self , v : [Byte ; 8]) -> Self { self . 0 = v ; self } pub fn nth0 (mut self , v : Byte) -> Self { self . 0 [0] = v ; self } pub fn nth1 (mut self , v : Byte) -> Self { self . 0 [1] = v ; self } pub fn nth2 (mut self , v : Byte) -> Self { self . 0 [2] = v ; self } pub fn nth3 (mut self , v : Byte) -> Self { self . 0 [3] = v ; self } pub fn nth4 (mut self , v : Byte) -> Self { self . 0 [4] = v ; self } pub fn nth5 (mut self , v : Byte) -> Self { self . 0 [5] = v ; self } pub fn nth6 (mut self , v : Byte) -> Self { self . 0 [6] = v ; self } pub fn nth7 (mut self , v : Byte) -> Self { self . 0 [7] = v ; self } } impl molecule :: prelude :: Builder for Uint64Builder { type Entity = Uint64 ; const NAME : & 'static str = "Uint64Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint64 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 8usize] > for Uint64 { fn from (value : [Byte ; 8usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Uint64 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 8usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Uint64 > for [Byte ; 8usize] { # [track_caller] fn from (value : Uint64) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () , value . nth4 () , value . nth5 () , value . nth6 () , value . nth7 () ,] } } impl From < [u8 ; 8usize] > for Uint64 { fn from (value : [u8 ; 8usize]) -> Self { Uint64Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Uint64 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 8usize] > :: try_from (value) ? . into ()) } } impl From < Uint64 > for [u8 ; 8usize] { # [track_caller] fn from (value : Uint64) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Uint64Reader < 'a >> for & 'a [u8 ; 8usize] { # [track_caller] fn from (value : Uint64Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Uint64Reader < 'a >> for & 'a [u8 ; 8usize] { # [track_caller] fn from (value : & 'a Uint64Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct Uint128 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint128 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint128 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint128 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Uint128 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint128 :: new_unchecked (v) } } impl Uint128 { const DEFAULT_VALUE : [u8 ; 16] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 16 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 16 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn nth8 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (8 .. 9)) } pub fn nth9 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (9 .. 10)) } pub fn nth10 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (10 .. 11)) } pub fn nth11 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (11 .. 12)) } pub fn nth12 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (12 .. 13)) } pub fn nth13 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (13 .. 14)) } pub fn nth14 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (14 .. 15)) } pub fn nth15 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (15 .. 16)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Uint128Reader < 'r > { Uint128Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint128 { type Builder = Uint128Builder ; const NAME : & 'static str = "Uint128" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint128 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint128Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint128Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () , self . nth8 () , self . nth9 () , self . nth10 () , self . nth11 () , self . nth12 () , self . nth13 () , self . nth14 () , self . nth15 () ,]) } }
# [derive (Clone , Copy)] pub struct Uint128Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint128Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint128Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint128Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Uint128Reader < 'r > { pub const TOTAL_SIZE : usize = 16 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 16 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn nth8 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [8 .. 9]) } pub fn nth9 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [9 .. 10]) } pub fn nth10 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [10 .. 11]) } pub fn nth11 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [11 .. 12]) } pub fn nth12 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [12 .. 13]) } pub fn nth13 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [13 .. 14]) } pub fn nth14 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [14 .. 15]) } pub fn nth15 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [15 .. 16]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint128Reader < 'r > { type Entity = Uint128 ; const NAME : & 'static str = "Uint128Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint128Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Uint128Builder (pub (crate) [Byte ; 16]) ; impl :: core :: fmt :: Debug for Uint128Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Uint128Builder { fn default () -> Self { Uint128Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl Uint128Builder { pub const TOTAL_SIZE : usize = 16 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 16 ; pub fn set (mut self , v : [Byte ; 16]) -> Self { self . 0 = v ; self } pub fn nth0 (mut self , v : Byte) -> Self { self . 0 [0] = v ; self } pub fn nth1 (mut self , v : Byte) -> Self { self . 0 [1] = v ; self } pub fn nth2 (mut self , v : Byte) -> Self { self . 0 [2] = v ; self } pub fn nth3 (mut self , v : Byte) -> Self { self . 0 [3] = v ; self } pub fn nth4 (mut self , v : Byte) -> Self { self . 0 [4] = v ; self } pub fn nth5 (mut self , v : Byte) -> Self { self . 0 [5] = v ; self } pub fn nth6 (mut self , v : Byte) -> Self { self . 0 [6] = v ; self } pub fn nth7 (mut self , v : Byte) -> Self { self . 0 [7] = v ; self } pub fn nth8 (mut self , v : Byte) -> Self { self . 0 [8] = v ; self } pub fn nth9 (mut self , v : Byte) -> Self { self . 0 [9] = v ; self } pub fn nth10 (mut self , v : Byte) -> Self { self . 0 [10] = v ; self } pub fn nth11 (mut self , v : Byte) -> Self { self . 0 [11] = v ; self } pub fn nth12 (mut self , v : Byte) -> Self { self . 0 [12] = v ; self } pub fn nth13 (mut self , v : Byte) -> Self { self . 0 [13] = v ; self } pub fn nth14 (mut self , v : Byte) -> Self { self . 0 [14] = v ; self } pub fn nth15 (mut self , v : Byte) -> Self { self . 0 [15] = v ; self } } impl molecule :: prelude :: Builder for Uint128Builder { type Entity = Uint128 ; const NAME : & 'static str = "Uint128Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; writer . write_all (self . 0 [8] . as_slice ()) ? ; writer . write_all (self . 0 [9] . as_slice ()) ? ; writer . write_all (self . 0 [10] . as_slice ()) ? ; writer . write_all (self . 0 [11] . as_slice ()) ? ; writer . write_all (self . 0 [12] . as_slice ()) ? ; writer . write_all (self . 0 [13] . as_slice ()) ? ; writer . write_all (self . 0 [14] . as_slice ()) ? ; writer . write_all (self . 0 [15] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint128 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 16usize] > for Uint128 { fn from (value : [Byte ; 16usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Uint128 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 16usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Uint128 > for [Byte ; 16usize] { # [track_caller] fn from (value : Uint128) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () , value . nth4 () , value . nth5 () , value . nth6 () , value . nth7 () , value . nth8 () , value . nth9 () , value . nth10 () , value . nth11 () , value . nth12 () , value . nth13 () , value . nth14 () , value . nth15 () ,] } } impl From < [u8 ; 16usize] > for Uint128 { fn from (value : [u8 ; 16usize]) -> Self { Uint128Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Uint128 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 16usize] > :: try_from (value) ? . into ()) } } impl From < Uint128 > for [u8 ; 16usize] { # [track_caller] fn from (value : Uint128) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Uint128Reader < 'a >> for & 'a [u8 ; 16usize] { # [track_caller] fn from (value : Uint128Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Uint128Reader < 'a >> for & 'a [u8 ; 16usize] { # [track_caller] fn from (value : & 'a Uint128Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct Byte32 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Byte32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Byte32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Byte32 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Byte32 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Byte32 :: new_unchecked (v) } } impl Byte32 { const DEFAULT_VALUE : [u8 ; 32] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn nth8 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (8 .. 9)) } pub fn nth9 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (9 .. 10)) } pub fn nth10 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (10 .. 11)) } pub fn nth11 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (11 .. 12)) } pub fn nth12 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (12 .. 13)) } pub fn nth13 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (13 .. 14)) } pub fn nth14 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (14 .. 15)) } pub fn nth15 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (15 .. 16)) } pub fn nth16 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (16 .. 17)) } pub fn nth17 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (17 .. 18)) } pub fn nth18 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (18 .. 19)) } pub fn nth19 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (19 .. 20)) } pub fn nth20 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (20 .. 21)) } pub fn nth21 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (21 .. 22)) } pub fn nth22 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (22 .. 23)) } pub fn nth23 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (23 .. 24)) } pub fn nth24 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (24 .. 25)) } pub fn nth25 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (25 .. 26)) } pub fn nth26 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (26 .. 27)) } pub fn nth27 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (27 .. 28)) } pub fn nth28 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (28 .. 29)) } pub fn nth29 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (29 .. 30)) } pub fn nth30 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (30 .. 31)) } pub fn nth31 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (31 .. 32)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Byte32Reader < 'r > { Byte32Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Byte32 { type Builder = Byte32Builder ; const NAME : & 'static str = "Byte32" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Byte32 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Byte32Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Byte32Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () , self . nth8 () , self . nth9 () , self . nth10 () , self . nth11 () , self . nth12 () , self . nth13 () , self . nth14 () , self . nth15 () , self . nth16 () , self . nth17 () , self . nth18 () , self . nth19 () , self . nth20 () , self . nth21 () , self . nth22 () , self . nth23 () , self . nth24 () , self . nth25 () , self . nth26 () , self . nth27 () , self . nth28 () , self . nth29 () , self . nth30 () , self . nth31 () ,]) } }
# [derive (Clone , Copy)] pub struct Byte32Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Byte32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Byte32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Byte32Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Byte32Reader < 'r > { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn nth8 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [8 .. 9]) } pub fn nth9 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [9 .. 10]) } pub fn nth10 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [10 .. 11]) } pub fn nth11 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [11 .. 12]) } pub fn nth12 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [12 .. 13]) } pub fn nth13 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [13 .. 14]) } pub fn nth14 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [14 .. 15]) } pub fn nth15 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [15 .. 16]) } pub fn nth16 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [16 .. 17]) } pub fn nth17 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [17 .. 18]) } pub fn nth18 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [18 .. 19]) } pub fn nth19 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [19 .. 20]) } pub fn nth20 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [20 .. 21]) } pub fn nth21 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [21 .. 22]) } pub fn nth22 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [22 .. 23]) } pub fn nth23 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [23 .. 24]) } pub fn nth24 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [24 .. 25]) } pub fn nth25 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [25 .. 26]) } pub fn nth26 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [26 .. 27]) } pub fn nth27 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [27 .. 28]) } pub fn nth28 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [28 .. 29]) } pub fn nth29 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [29 .. 30]) } pub fn nth30 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [30 .. 31]) } pub fn nth31 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [31 .. 32]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Byte32Reader < 'r > { type Entity = Byte32 ; const NAME : & 'static str = "Byte32Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Byte32Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Byte32Builder (pub (crate) [Byte ; 32]) ; impl :: core :: fmt :: Debug for Byte32Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Byte32Builder { fn default () -> Self { Byte32Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl Byte32Builder { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn set (mut self , v : [Byte ; 32]) -> Self { self . 0 = v ; self } pub fn nth0 (mut self , v : Byte) -> Self { self . 0 [0] = v ; self } pub fn nth1 (mut self , v : Byte) -> Self { self . 0 [1] = v ; self } pub fn nth2 (mut self , v : Byte) -> Self { self . 0 [2] = v ; self } pub fn nth3 (mut self , v : Byte) -> Self { self . 0 [3] = v ; self } pub fn nth4 (mut self , v : Byte) -> Self { self . 0 [4] = v ; self } pub fn nth5 (mut self , v : Byte) -> Self { self . 0 [5] = v ; self } pub fn nth6 (mut self , v : Byte) -> Self { self . 0 [6] = v ; self } pub fn nth7 (mut self , v : Byte) -> Self { self . 0 [7] = v ; self } pub fn nth8 (mut self , v : Byte) -> Self { self . 0 [8] = v ; self } pub fn nth9 (mut self , v : Byte) -> Self { self . 0 [9] = v ; self } pub fn nth10 (mut self , v : Byte) -> Self { self . 0 [10] = v ; self } pub fn nth11 (mut self , v : Byte) -> Self { self . 0 [11] = v ; self } pub fn nth12 (mut self , v : Byte) -> Self { self . 0 [12] = v ; self } pub fn nth13 (mut self , v : Byte) -> Self { self . 0 [13] = v ; self } pub fn nth14 (mut self , v : Byte) -> Self { self . 0 [14] = v ; self } pub fn nth15 (mut self , v : Byte) -> Self { self . 0 [15] = v ; self } pub fn nth16 (mut self , v : Byte) -> Self { self . 0 [16] = v ; self } pub fn nth17 (mut self , v : Byte) -> Self { self . 0 [17] = v ; self } pub fn nth18 (mut self , v : Byte) -> Self { self . 0 [18] = v ; self } pub fn nth19 (mut self , v : Byte) -> Self { self . 0 [19] = v ; self } pub fn nth20 (mut self , v : Byte) -> Self { self . 0 [20] = v ; self } pub fn nth21 (mut self , v : Byte) -> Self { self . 0 [21] = v ; self } pub fn nth22 (mut self , v : Byte) -> Self { self . 0 [22] = v ; self } pub fn nth23 (mut self , v : Byte) -> Self { self . 0 [23] = v ; self } pub fn nth24 (mut self , v : Byte) -> Self { self . 0 [24] = v ; self } pub fn nth25 (mut self , v : Byte) -> Self { self . 0 [25] = v ; self } pub fn nth26 (mut self , v : Byte) -> Self { self . 0 [26] = v ; self } pub fn nth27 (mut self , v : Byte) -> Self { self . 0 [27] = v ; self } pub fn nth28 (mut self , v : Byte) -> Self { self . 0 [28] = v ; self } pub fn nth29 (mut self , v : Byte) -> Self { self . 0 [29] = v ; self } pub fn nth30 (mut self , v : Byte) -> Self { self . 0 [30] = v ; self } pub fn nth31 (mut self , v : Byte) -> Self { self . 0 [31] = v ; self } } impl molecule :: prelude :: Builder for Byte32Builder { type Entity = Byte32 ; const NAME : & 'static str = "Byte32Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; writer . write_all (self . 0 [8] . as_slice ()) ? ; writer . write_all (self . 0 [9] . as_slice ()) ? ; writer . write_all (self . 0 [10] . as_slice ()) ? ; writer . write_all (self . 0 [11] . as_slice ()) ? ; writer . write_all (self . 0 [12] . as_slice ()) ? ; writer . write_all (self . 0 [13] . as_slice ()) ? ; writer . write_all (self . 0 [14] . as_slice ()) ? ; writer . write_all (self . 0 [15] . as_slice ()) ? ; writer . write_all (self . 0 [16] . as_slice ()) ? ; writer . write_all (self . 0 [17] . as_slice ()) ? ; writer . write_all (self . 0 [18] . as_slice ()) ? ; writer . write_all (self . 0 [19] . as_slice ()) ? ; writer . write_all (self . 0 [20] . as_slice ()) ? ; writer . write_all (self . 0 [21] . as_slice ()) ? ; writer . write_all (self . 0 [22] . as_slice ()) ? ; writer . write_all (self . 0 [23] . as_slice ()) ? ; writer . write_all (self . 0 [24] . as_slice ()) ? ; writer . write_all (self . 0 [25] . as_slice ()) ? ; writer . write_all (self . 0 [26] . as_slice ()) ? ; writer . write_all (self . 0 [27] . as_slice ()) ? ; writer . write_all (self . 0 [28] . as_slice ()) ? ; writer . write_all (self . 0 [29] . as_slice ()) ? ; writer . write_all (self . 0 [30] . as_slice ()) ? ; writer . write_all (self . 0 [31] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Byte32 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 32usize] > for Byte32 { fn from (value : [Byte ; 32usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Byte32 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 32usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Byte32 > for [Byte ; 32usize] { # [track_caller] fn from (value : Byte32) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () , value . nth4 () , value . nth5 () , value . nth6 () , value . nth7 () , value . nth8 () , value . nth9 () , value . nth10 () , value . nth11 () , value . nth12 () , value . nth13 () , value . nth14 () , value . nth15 () , value . nth16 () , value . nth17 () , value . nth18 () , value . nth19 () , value . nth20 () , value . nth21 () , value . nth22 () , value . nth23 () , value . nth24 () , value . nth25 () , value . nth26 () , value . nth27 () , value . nth28 () , value . nth29 () , value . nth30 () , value . nth31 () ,] } } impl From < [u8 ; 32usize] > for Byte32 { fn from (value : [u8 ; 32usize]) -> Self { Byte32Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Byte32 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 32usize] > :: try_from (value) ? . into ()) } } impl From < Byte32 > for [u8 ; 32usize] { # [track_caller] fn from (value : Byte32) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Byte32Reader < 'a >> for & 'a [u8 ; 32usize] { # [track_caller] fn from (value : Byte32Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Byte32Reader < 'a >> for & 'a [u8 ; 32usize] { # [track_caller] fn from (value : & 'a Byte32Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct Uint256 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint256 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint256 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint256 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Uint256 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint256 :: new_unchecked (v) } } impl Uint256 { const DEFAULT_VALUE : [u8 ; 32] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn nth8 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (8 .. 9)) } pub fn nth9 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (9 .. 10)) } pub fn nth10 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (10 .. 11)) } pub fn nth11 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (11 .. 12)) } pub fn nth12 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (12 .. 13)) } pub fn nth13 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (13 .. 14)) } pub fn nth14 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (14 .. 15)) } pub fn nth15 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (15 .. 16)) } pub fn nth16 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (16 .. 17)) } pub fn nth17 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (17 .. 18)) } pub fn nth18 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (18 .. 19)) } pub fn nth19 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (19 .. 20)) } pub fn nth20 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (20 .. 21)) } pub fn nth21 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (21 .. 22)) } pub fn nth22 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (22 .. 23)) } pub fn nth23 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (23 .. 24)) } pub fn nth24 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (24 .. 25)) } pub fn nth25 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (25 .. 26)) } pub fn nth26 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (26 .. 27)) } pub fn nth27 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (27 .. 28)) } pub fn nth28 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (28 .. 29)) } pub fn nth29 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (29 .. 30)) } pub fn nth30 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (30 .. 31)) } pub fn nth31 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (31 .. 32)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> Uint256Reader < 'r > { Uint256Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint256 { type Builder = Uint256Builder ; const NAME : & 'static str = "Uint256" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint256 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint256Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint256Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () , self . nth8 () , self . nth9 () , self . nth10 () , self . nth11 () , self . nth12 () , self . nth13 () , self . nth14 () , self . nth15 () , self . nth16 () , self . nth17 () , self . nth18 () , self . nth19 () , self . nth20 () , self . nth21 () , self . nth22 () , self . nth23 () , self . nth24 () , self . nth25 () , self . nth26 () , self . nth27 () , self . nth28 () , self . nth29 () , self . nth30 () , self . nth31 () ,]) } }
# [derive (Clone , Copy)] pub struct Uint256Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint256Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint256Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint256Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > Uint256Reader < 'r > { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn nth8 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [8 .. 9]) } pub fn nth9 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [9 .. 10]) } pub fn nth10 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [10 .. 11]) } pub fn nth11 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [11 .. 12]) } pub fn nth12 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [12 .. 13]) } pub fn nth13 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [13 .. 14]) } pub fn nth14 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [14 .. 15]) } pub fn nth15 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [15 .. 16]) } pub fn nth16 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [16 .. 17]) } pub fn nth17 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [17 .. 18]) } pub fn nth18 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [18 .. 19]) } pub fn nth19 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [19 .. 20]) } pub fn nth20 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [20 .. 21]) } pub fn nth21 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [21 .. 22]) } pub fn nth22 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [22 .. 23]) } pub fn nth23 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [23 .. 24]) } pub fn nth24 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [24 .. 25]) } pub fn nth25 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [25 .. 26]) } pub fn nth26 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [26 .. 27]) } pub fn nth27 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [27 .. 28]) } pub fn nth28 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [28 .. 29]) } pub fn nth29 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [29 .. 30]) } pub fn nth30 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [30 .. 31]) } pub fn nth31 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [31 .. 32]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint256Reader < 'r > { type Entity = Uint256 ; const NAME : & 'static str = "Uint256Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint256Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct Uint256Builder (pub (crate) [Byte ; 32]) ; impl :: core :: fmt :: Debug for Uint256Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for Uint256Builder { fn default () -> Self { Uint256Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl Uint256Builder { pub const TOTAL_SIZE : usize = 32 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 32 ; pub fn set (mut self , v : [Byte ; 32]) -> Self { self . 0 = v ; self } pub fn nth0 (mut self , v : Byte) -> Self { self . 0 [0] = v ; self } pub fn nth1 (mut self , v : Byte) -> Self { self . 0 [1] = v ; self } pub fn nth2 (mut self , v : Byte) -> Self { self . 0 [2] = v ; self } pub fn nth3 (mut self , v : Byte) -> Self { self . 0 [3] = v ; self } pub fn nth4 (mut self , v : Byte) -> Self { self . 0 [4] = v ; self } pub fn nth5 (mut self , v : Byte) -> Self { self . 0 [5] = v ; self } pub fn nth6 (mut self , v : Byte) -> Self { self . 0 [6] = v ; self } pub fn nth7 (mut self , v : Byte) -> Self { self . 0 [7] = v ; self } pub fn nth8 (mut self , v : Byte) -> Self { self . 0 [8] = v ; self } pub fn nth9 (mut self , v : Byte) -> Self { self . 0 [9] = v ; self } pub fn nth10 (mut self , v : Byte) -> Self { self . 0 [10] = v ; self } pub fn nth11 (mut self , v : Byte) -> Self { self . 0 [11] = v ; self } pub fn nth12 (mut self , v : Byte) -> Self { self . 0 [12] = v ; self } pub fn nth13 (mut self , v : Byte) -> Self { self . 0 [13] = v ; self } pub fn nth14 (mut self , v : Byte) -> Self { self . 0 [14] = v ; self } pub fn nth15 (mut self , v : Byte) -> Self { self . 0 [15] = v ; self } pub fn nth16 (mut self , v : Byte) -> Self { self . 0 [16] = v ; self } pub fn nth17 (mut self , v : Byte) -> Self { self . 0 [17] = v ; self } pub fn nth18 (mut self , v : Byte) -> Self { self . 0 [18] = v ; self } pub fn nth19 (mut self , v : Byte) -> Self { self . 0 [19] = v ; self } pub fn nth20 (mut self , v : Byte) -> Self { self . 0 [20] = v ; self } pub fn nth21 (mut self , v : Byte) -> Self { self . 0 [21] = v ; self } pub fn nth22 (mut self , v : Byte) -> Self { self . 0 [22] = v ; self } pub fn nth23 (mut self , v : Byte) -> Self { self . 0 [23] = v ; self } pub fn nth24 (mut self , v : Byte) -> Self { self . 0 [24] = v ; self } pub fn nth25 (mut self , v : Byte) -> Self { self . 0 [25] = v ; self } pub fn nth26 (mut self , v : Byte) -> Self { self . 0 [26] = v ; self } pub fn nth27 (mut self , v : Byte) -> Self { self . 0 [27] = v ; self } pub fn nth28 (mut self , v : Byte) -> Self { self . 0 [28] = v ; self } pub fn nth29 (mut self , v : Byte) -> Self { self . 0 [29] = v ; self } pub fn nth30 (mut self , v : Byte) -> Self { self . 0 [30] = v ; self } pub fn nth31 (mut self , v : Byte) -> Self { self . 0 [31] = v ; self } } impl molecule :: prelude :: Builder for Uint256Builder { type Entity = Uint256 ; const NAME : & 'static str = "Uint256Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; writer . write_all (self . 0 [8] . as_slice ()) ? ; writer . write_all (self . 0 [9] . as_slice ()) ? ; writer . write_all (self . 0 [10] . as_slice ()) ? ; writer . write_all (self . 0 [11] . as_slice ()) ? ; writer . write_all (self . 0 [12] . as_slice ()) ? ; writer . write_all (self . 0 [13] . as_slice ()) ? ; writer . write_all (self . 0 [14] . as_slice ()) ? ; writer . write_all (self . 0 [15] . as_slice ()) ? ; writer . write_all (self . 0 [16] . as_slice ()) ? ; writer . write_all (self . 0 [17] . as_slice ()) ? ; writer . write_all (self . 0 [18] . as_slice ()) ? ; writer . write_all (self . 0 [19] . as_slice ()) ? ; writer . write_all (self . 0 [20] . as_slice ()) ? ; writer . write_all (self . 0 [21] . as_slice ()) ? ; writer . write_all (self . 0 [22] . as_slice ()) ? ; writer . write_all (self . 0 [23] . as_slice ()) ? ; writer . write_all (self . 0 [24] . as_slice ()) ? ; writer . write_all (self . 0 [25] . as_slice ()) ? ; writer . write_all (self . 0 [26] . as_slice ()) ? ; writer . write_all (self . 0 [27] . as_slice ()) ? ; writer . write_all (self . 0 [28] . as_slice ()) ? ; writer . write_all (self . 0 [29] . as_slice ()) ? ; writer . write_all (self . 0 [30] . as_slice ()) ? ; writer . write_all (self . 0 [31] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint256 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 32usize] > for Uint256 { fn from (value : [Byte ; 32usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Uint256 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 32usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Uint256 > for [Byte ; 32usize] { # [track_caller] fn from (value : Uint256) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () , value . nth4 () , value . nth5 () , value . nth6 () , value . nth7 () , value . nth8 () , value . nth9 () , value . nth10 () , value . nth11 () , value . nth12 () , value . nth13 () , value . nth14 () , value . nth15 () , value . nth16 () , value . nth17 () , value . nth18 () , value . nth19 () , value . nth20 () , value . nth21 () , value . nth22 () , value . nth23 () , value . nth24 () , value . nth25 () , value . nth26 () , value . nth27 () , value . nth28 () , value . nth29 () , value . nth30 () , value . nth31 () ,] } } impl From < [u8 ; 32usize] > for Uint256 { fn from (value : [u8 ; 32usize]) -> Self { Uint256Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Uint256 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 32usize] > :: try_from (value) ? . into ()) } } impl From < Uint256 > for [u8 ; 32usize] { # [track_caller] fn from (value : Uint256) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < Uint256Reader < 'a >> for & 'a [u8 ; 32usize] { # [track_caller] fn from (value : Uint256Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a Uint256Reader < 'a >> for & 'a [u8 ; 32usize] { # [track_caller] fn from (value : & 'a Uint256Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct F64 (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for F64 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for F64 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for F64 { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for F64 { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; F64 :: new_unchecked (v) } } impl F64 { const DEFAULT_VALUE : [u8 ; 8] = [0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ,] ; pub const TOTAL_SIZE : usize = 8 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 8 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn nth1 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (1 .. 2)) } pub fn nth2 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (2 .. 3)) } pub fn nth3 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (3 .. 4)) } pub fn nth4 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (4 .. 5)) } pub fn nth5 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (5 .. 6)) } pub fn nth6 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (6 .. 7)) } pub fn nth7 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (7 .. 8)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> F64Reader < 'r > { F64Reader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for F64 { type Builder = F64Builder ; const NAME : & 'static str = "F64" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { F64 (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { F64Reader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { F64Reader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () , self . nth1 () , self . nth2 () , self . nth3 () , self . nth4 () , self . nth5 () , self . nth6 () , self . nth7 () ,]) } }
# [derive (Clone , Copy)] pub struct F64Reader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for F64Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for F64Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for F64Reader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > F64Reader < 'r > { pub const TOTAL_SIZE : usize = 8 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 8 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn nth1 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [1 .. 2]) } pub fn nth2 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [2 .. 3]) } pub fn nth3 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [3 .. 4]) } pub fn nth4 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [4 .. 5]) } pub fn nth5 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [5 .. 6]) } pub fn nth6 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [6 .. 7]) } pub fn nth7 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [7 .. 8]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for F64Reader < 'r > { type Entity = F64 ; const NAME : & 'static str = "F64Reader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { F64Reader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct F64Builder (pub (crate) [Byte ; 8]) ; impl :: core :: fmt :: Debug for F64Builder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for F64Builder { fn default () -> Self { F64Builder ([Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () , Byte :: default () ,]) } } impl F64Builder { pub const TOTAL_SIZE : usize = 8 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 8 ; pub fn set (mut self , v : [Byte ; 8]) -> Self { self . 0 = v ; self } pub fn nth0 (mut self , v : Byte) -> Self { self . 0 [0] = v ; self } pub fn nth1 (mut self , v : Byte) -> Self { self . 0 [1] = v ; self } pub fn nth2 (mut self , v : Byte) -> Self { self . 0 [2] = v ; self } pub fn nth3 (mut self , v : Byte) -> Self { self . 0 [3] = v ; self } pub fn nth4 (mut self , v : Byte) -> Self { self . 0 [4] = v ; self } pub fn nth5 (mut self , v : Byte) -> Self { self . 0 [5] = v ; self } pub fn nth6 (mut self , v : Byte) -> Self { self . 0 [6] = v ; self } pub fn nth7 (mut self , v : Byte) -> Self { self . 0 [7] = v ; self } } impl molecule :: prelude :: Builder for F64Builder { type Entity = F64 ; const NAME : & 'static str = "F64Builder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; writer . write_all (self . 0 [1] . as_slice ()) ? ; writer . write_all (self . 0 [2] . as_slice ()) ? ; writer . write_all (self . 0 [3] . as_slice ()) ? ; writer . write_all (self . 0 [4] . as_slice ()) ? ; writer . write_all (self . 0 [5] . as_slice ()) ? ; writer . write_all (self . 0 [6] . as_slice ()) ? ; writer . write_all (self . 0 [7] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; F64 :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 8usize] > for F64 { fn from (value : [Byte ; 8usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for F64 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 8usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < F64 > for [Byte ; 8usize] { # [track_caller] fn from (value : F64) -> Self { [value . nth0 () , value . nth1 () , value . nth2 () , value . nth3 () , value . nth4 () , value . nth5 () , value . nth6 () , value . nth7 () ,] } } impl From < [u8 ; 8usize] > for F64 { fn from (value : [u8 ; 8usize]) -> Self { F64Reader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for F64 { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 8usize] > :: try_from (value) ? . into ()) } } impl From < F64 > for [u8 ; 8usize] { # [track_caller] fn from (value : F64) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < F64Reader < 'a >> for & 'a [u8 ; 8usize] { # [track_caller] fn from (value : F64Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a F64Reader < 'a >> for & 'a [u8 ; 8usize] { # [track_caller] fn from (value : & 'a F64Reader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct Bytes (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Bytes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Bytes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Bytes { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Bytes { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Bytes :: new_unchecked (v) } } impl Bytes { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Byte > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Byte { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte :: new_unchecked (self . 0 . slice (start .. end)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . 0 . slice (molecule :: NUMBER_SIZE ..) } pub fn as_reader < 'r > (& 'r self) -> BytesReader < 'r > { BytesReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Bytes { type Builder = BytesBuilder ; const NAME : & 'static str = "Bytes" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Bytes (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct BytesReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BytesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BytesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BytesReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > BytesReader < 'r > { pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ByteReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ByteReader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; ByteReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn raw_data (& self) -> & 'r [u8] { & self . as_slice () [molecule :: NUMBER_SIZE ..] } } impl < 'r > molecule :: prelude :: Reader < 'r > for BytesReader < 'r > { type Entity = Bytes ; const NAME : & 'static str = "BytesReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BytesReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct BytesBuilder (pub (crate) Vec < Byte >) ; impl BytesBuilder { pub const ITEM_SIZE : usize = 1 ; pub fn set (mut self , v : Vec < Byte >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : Byte) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Byte >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } pub fn replace (& mut self , index : usize , v : Byte) -> Option < Byte > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v)) } } impl molecule :: prelude :: Builder for BytesBuilder { type Entity = Bytes ; const NAME : & 'static str = "BytesBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Bytes :: new_unchecked (inner . into ()) } }
pub struct BytesIterator (Bytes , usize , usize) ; impl :: core :: iter :: Iterator for BytesIterator { type Item = Byte ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for BytesIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for Bytes { type Item = Byte ; type IntoIter = BytesIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; BytesIterator (self , 0 , len) } }
impl :: core :: iter :: FromIterator < Byte > for Bytes { fn from_iter < T : IntoIterator < Item = Byte >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl :: core :: iter :: FromIterator < u8 > for Bytes { fn from_iter < T : IntoIterator < Item = u8 >> (iter : T) -> Self { Self :: new_builder () . extend (iter . into_iter () . map (Into :: into)) . build () } }
# [derive (Clone)] pub struct BytesOpt (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for BytesOpt { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for BytesOpt { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for BytesOpt { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { if let Some (v) = self . to_opt () { write ! (f , "{}(Some({}))" , Self :: NAME , v) } else { write ! (f , "{}(None)" , Self :: NAME) } } } impl :: core :: default :: Default for BytesOpt { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; BytesOpt :: new_unchecked (v) } } impl BytesOpt { const DEFAULT_VALUE : [u8 ; 0] = [] ; pub fn is_none (& self) -> bool { self . 0 . is_empty () } pub fn is_some (& self) -> bool { ! self . 0 . is_empty () } pub fn to_opt (& self) -> Option < Bytes > { if self . is_none () { None } else { Some (Bytes :: new_unchecked (self . 0 . clone ())) } } pub fn as_reader < 'r > (& 'r self) -> BytesOptReader < 'r > { BytesOptReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for BytesOpt { type Builder = BytesOptBuilder ; const NAME : & 'static str = "BytesOpt" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { BytesOpt (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesOptReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesOptReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set (self . to_opt ()) } }
# [derive (Clone , Copy)] pub struct BytesOptReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BytesOptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BytesOptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BytesOptReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { if let Some (v) = self . to_opt () { write ! (f , "{}(Some({}))" , Self :: NAME , v) } else { write ! (f , "{}(None)" , Self :: NAME) } } } impl < 'r > BytesOptReader < 'r > { pub fn is_none (& self) -> bool { self . 0 . is_empty () } pub fn is_some (& self) -> bool { ! self . 0 . is_empty () } pub fn to_opt (& self) -> Option < BytesReader < 'r > > { if self . is_none () { None } else { Some (BytesReader :: new_unchecked (self . as_slice ())) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for BytesOptReader < 'r > { type Entity = BytesOpt ; const NAME : & 'static str = "BytesOptReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BytesOptReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { if ! slice . is_empty () { BytesReader :: verify (& slice [..] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct BytesOptBuilder (pub (crate) Option < Bytes >) ; impl BytesOptBuilder { pub fn set (mut self , v : Option < Bytes >) -> Self { self . 0 = v ; self } } impl molecule :: prelude :: Builder for BytesOptBuilder { type Entity = BytesOpt ; const NAME : & 'static str = "BytesOptBuilder" ; fn expected_length (& self) -> usize { self . 0 . as_ref () . map (| ref inner | inner . as_slice () . len ()) . unwrap_or (0) } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { self . 0 . as_ref () . map (| ref inner | writer . write_all (inner . as_slice ())) . unwrap_or (Ok (())) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; BytesOpt :: new_unchecked (inner . into ()) } }
impl From < Bytes > for BytesOpt { fn from (value : Bytes) -> Self { Self :: new_builder () . set (Some (value)) . build () } }
# [derive (Clone)] pub struct BytesVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for BytesVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for BytesVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for BytesVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for BytesVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; BytesVec :: new_unchecked (v) } } impl BytesVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Bytes > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Bytes { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { Bytes :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; Bytes :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> BytesVecReader < 'r > { BytesVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for BytesVec { type Builder = BytesVecBuilder ; const NAME : & 'static str = "BytesVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { BytesVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BytesVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct BytesVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BytesVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BytesVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BytesVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > BytesVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < BytesReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> BytesReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { BytesReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; BytesReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for BytesVecReader < 'r > { type Entity = BytesVec ; const NAME : & 'static str = "BytesVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BytesVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; BytesReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct BytesVecBuilder (pub (crate) Vec < Bytes >) ; impl BytesVecBuilder { pub fn set (mut self , v : Vec < Bytes >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : Bytes) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Bytes >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } pub fn replace (& mut self , index : usize , v : Bytes) -> Option < Bytes > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v)) } } impl molecule :: prelude :: Builder for BytesVecBuilder { type Entity = BytesVec ; const NAME : & 'static str = "BytesVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; BytesVec :: new_unchecked (inner . into ()) } }
pub struct BytesVecIterator (BytesVec , usize , usize) ; impl :: core :: iter :: Iterator for BytesVecIterator { type Item = Bytes ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for BytesVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for BytesVec { type Item = Bytes ; type IntoIter = BytesVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; BytesVecIterator (self , 0 , len) } } impl < 'r > BytesVecReader < 'r > { pub fn iter < 't > (& 't self) -> BytesVecReaderIterator < 't , 'r > { BytesVecReaderIterator (& self , 0 , self . len ()) } } pub struct BytesVecReaderIterator < 't , 'r > (& 't BytesVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for BytesVecReaderIterator < 't , 'r > { type Item = BytesReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for BytesVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < Bytes > for BytesVec { fn from_iter < T : IntoIterator < Item = Bytes >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } }
# [derive (Clone)] pub struct Byte32Vec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Byte32Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Byte32Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Byte32Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for Byte32Vec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Byte32Vec :: new_unchecked (v) } } impl Byte32Vec { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 32 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Byte32 > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Byte32 { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte32 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn as_reader < 'r > (& 'r self) -> Byte32VecReader < 'r > { Byte32VecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Byte32Vec { type Builder = Byte32VecBuilder ; const NAME : & 'static str = "Byte32Vec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Byte32Vec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Byte32VecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Byte32VecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct Byte32VecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Byte32VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Byte32VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Byte32VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > Byte32VecReader < 'r > { pub const ITEM_SIZE : usize = 32 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Byte32Reader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Byte32Reader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte32Reader :: new_unchecked (& self . as_slice () [start .. end]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for Byte32VecReader < 'r > { type Entity = Byte32Vec ; const NAME : & 'static str = "Byte32VecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Byte32VecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct Byte32VecBuilder (pub (crate) Vec < Byte32 >) ; impl Byte32VecBuilder { pub const ITEM_SIZE : usize = 32 ; pub fn set (mut self , v : Vec < Byte32 >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : Byte32) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Byte32 >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } pub fn replace (& mut self , index : usize , v : Byte32) -> Option < Byte32 > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v)) } } impl molecule :: prelude :: Builder for Byte32VecBuilder { type Entity = Byte32Vec ; const NAME : & 'static str = "Byte32VecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Byte32Vec :: new_unchecked (inner . into ()) } }
pub struct Byte32VecIterator (Byte32Vec , usize , usize) ; impl :: core :: iter :: Iterator for Byte32VecIterator { type Item = Byte32 ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for Byte32VecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for Byte32Vec { type Item = Byte32 ; type IntoIter = Byte32VecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; Byte32VecIterator (self , 0 , len) } } impl < 'r > Byte32VecReader < 'r > { pub fn iter < 't > (& 't self) -> Byte32VecReaderIterator < 't , 'r > { Byte32VecReaderIterator (& self , 0 , self . len ()) } } pub struct Byte32VecReaderIterator < 't , 'r > (& 't Byte32VecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for Byte32VecReaderIterator < 't , 'r > { type Item = Byte32Reader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for Byte32VecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < Byte32 > for Byte32Vec { fn from_iter < T : IntoIterator < Item = Byte32 >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } }
# [derive (Clone)] pub struct Bool (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Bool { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Bool { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Bool { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for Bool { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Bool :: new_unchecked (v) } } impl Bool { const DEFAULT_VALUE : [u8 ; 1] = [0 ,] ; pub const TOTAL_SIZE : usize = 1 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 1 ; pub fn nth0 (& self) -> Byte { Byte :: new_unchecked (self . 0 . slice (0 .. 1)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . as_bytes () } pub fn as_reader < 'r > (& 'r self) -> BoolReader < 'r > { BoolReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Bool { type Builder = BoolBuilder ; const NAME : & 'static str = "Bool" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Bool (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BoolReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { BoolReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . set ([self . nth0 () ,]) } }
# [derive (Clone , Copy)] pub struct BoolReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for BoolReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for BoolReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for BoolReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > BoolReader < 'r > { pub const TOTAL_SIZE : usize = 1 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 1 ; pub fn nth0 (& self) -> ByteReader < 'r > { ByteReader :: new_unchecked (& self . as_slice () [0 .. 1]) } pub fn raw_data (& self) -> & 'r [u8] { self . as_slice () } } impl < 'r > molecule :: prelude :: Reader < 'r > for BoolReader < 'r > { type Entity = Bool ; const NAME : & 'static str = "BoolReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { BoolReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len != Self :: TOTAL_SIZE { return ve ! (Self , TotalSizeNotMatch , Self :: TOTAL_SIZE , slice_len) ; } Ok (()) } }
# [derive (Clone)] pub struct BoolBuilder (pub (crate) [Byte ; 1]) ; impl :: core :: fmt :: Debug for BoolBuilder { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:?})" , Self :: NAME , & self . 0 [..]) } } impl :: core :: default :: Default for BoolBuilder { fn default () -> Self { BoolBuilder ([Byte :: default () ,]) } } impl BoolBuilder { pub const TOTAL_SIZE : usize = 1 ; pub const ITEM_SIZE : usize = 1 ; pub const ITEM_COUNT : usize = 1 ; pub fn set (mut self , v : [Byte ; 1]) -> Self { self . 0 = v ; self } pub fn nth0 (mut self , v : Byte) -> Self { self . 0 [0] = v ; self } } impl molecule :: prelude :: Builder for BoolBuilder { type Entity = Bool ; const NAME : & 'static str = "BoolBuilder" ; fn expected_length (& self) -> usize { Self :: TOTAL_SIZE } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (self . 0 [0] . as_slice ()) ? ; Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Bool :: new_unchecked (inner . into ()) } }
impl From < [Byte ; 1usize] > for Bool { fn from (value : [Byte ; 1usize]) -> Self { Self :: new_builder () . set (value) . build () } } impl :: core :: convert :: TryFrom < & [Byte] > for Bool { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [Byte]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (Self :: new_builder () . set (< & [Byte ; 1usize] > :: try_from (value) ? . clone ()) . build ()) } } impl From < Bool > for [Byte ; 1usize] { # [track_caller] fn from (value : Bool) -> Self { [value . nth0 () ,] } } impl From < [u8 ; 1usize] > for Bool { fn from (value : [u8 ; 1usize]) -> Self { BoolReader :: new_unchecked (& value) . to_entity () } } impl :: core :: convert :: TryFrom < & [u8] > for Bool { type Error = :: core :: array :: TryFromSliceError ; fn try_from (value : & [u8]) -> Result < Self , :: core :: array :: TryFromSliceError > { Ok (< [u8 ; 1usize] > :: try_from (value) ? . into ()) } } impl From < Bool > for [u8 ; 1usize] { # [track_caller] fn from (value : Bool) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < BoolReader < 'a >> for & 'a [u8 ; 1usize] { # [track_caller] fn from (value : BoolReader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } } impl < 'a > From < & 'a BoolReader < 'a >> for & 'a [u8 ; 1usize] { # [track_caller] fn from (value : & 'a BoolReader < 'a >) -> Self { :: core :: convert :: TryFrom :: try_from (value . as_slice ()) . unwrap () } }
# [derive (Clone)] pub struct UTF8String (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for UTF8String { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for UTF8String { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for UTF8String { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl :: core :: default :: Default for UTF8String { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; UTF8String :: new_unchecked (v) } } impl UTF8String { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Byte > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Byte { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Byte :: new_unchecked (self . 0 . slice (start .. end)) } pub fn raw_data (& self) -> molecule :: bytes :: Bytes { self . 0 . slice (molecule :: NUMBER_SIZE ..) } pub fn as_reader < 'r > (& 'r self) -> UTF8StringReader < 'r > { UTF8StringReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for UTF8String { type Builder = UTF8StringBuilder ; const NAME : & 'static str = "UTF8String" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { UTF8String (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UTF8StringReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UTF8StringReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct UTF8StringReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for UTF8StringReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for UTF8StringReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for UTF8StringReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; let raw_data = hex_string (& self . raw_data ()) ; write ! (f , "{}(0x{})" , Self :: NAME , raw_data) } } impl < 'r > UTF8StringReader < 'r > { pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < ByteReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> ByteReader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; ByteReader :: new_unchecked (& self . as_slice () [start .. end]) } pub fn raw_data (& self) -> & 'r [u8] { & self . as_slice () [molecule :: NUMBER_SIZE ..] } } impl < 'r > molecule :: prelude :: Reader < 'r > for UTF8StringReader < 'r > { type Entity = UTF8String ; const NAME : & 'static str = "UTF8StringReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { UTF8StringReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct UTF8StringBuilder (pub (crate) Vec < Byte >) ; impl UTF8StringBuilder { pub const ITEM_SIZE : usize = 1 ; pub fn set (mut self , v : Vec < Byte >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : Byte) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Byte >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } pub fn replace (& mut self , index : usize , v : Byte) -> Option < Byte > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v)) } } impl molecule :: prelude :: Builder for UTF8StringBuilder { type Entity = UTF8String ; const NAME : & 'static str = "UTF8StringBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; UTF8String :: new_unchecked (inner . into ()) } }
pub struct UTF8StringIterator (UTF8String , usize , usize) ; impl :: core :: iter :: Iterator for UTF8StringIterator { type Item = Byte ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for UTF8StringIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for UTF8String { type Item = Byte ; type IntoIter = UTF8StringIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; UTF8StringIterator (self , 0 , len) } }
impl :: core :: iter :: FromIterator < Byte > for UTF8String { fn from_iter < T : IntoIterator < Item = Byte >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } } impl :: core :: iter :: FromIterator < u8 > for UTF8String { fn from_iter < T : IntoIterator < Item = u8 >> (iter : T) -> Self { Self :: new_builder () . extend (iter . into_iter () . map (Into :: into)) . build () } }
# [derive (Clone)] pub struct UTF8StringVec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for UTF8StringVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for UTF8StringVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for UTF8StringVec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for UTF8StringVec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; UTF8StringVec :: new_unchecked (v) } } impl UTF8StringVec { const DEFAULT_VALUE : [u8 ; 4] = [4 , 0 , 0 , 0 ,] ; pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < UTF8String > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> UTF8String { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { UTF8String :: new_unchecked (self . 0 . slice (start ..)) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; UTF8String :: new_unchecked (self . 0 . slice (start .. end)) } } pub fn as_reader < 'r > (& 'r self) -> UTF8StringVecReader < 'r > { UTF8StringVecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for UTF8StringVec { type Builder = UTF8StringVecBuilder ; const NAME : & 'static str = "UTF8StringVec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { UTF8StringVec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UTF8StringVecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { UTF8StringVecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct UTF8StringVecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for UTF8StringVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for UTF8StringVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for UTF8StringVecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > UTF8StringVecReader < 'r > { pub fn total_size (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn item_count (& self) -> usize { if self . total_size () == molecule :: NUMBER_SIZE { 0 } else { (molecule :: unpack_number (& self . as_slice () [molecule :: NUMBER_SIZE ..]) as usize / 4) - 1 } } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < UTF8StringReader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> UTF8StringReader < 'r > { let slice = self . as_slice () ; let start_idx = molecule :: NUMBER_SIZE * (1 + idx) ; let start = molecule :: unpack_number (& slice [start_idx ..]) as usize ; if idx == self . len () - 1 { UTF8StringReader :: new_unchecked (& self . as_slice () [start ..]) } else { let end_idx = start_idx + molecule :: NUMBER_SIZE ; let end = molecule :: unpack_number (& slice [end_idx ..]) as usize ; UTF8StringReader :: new_unchecked (& self . as_slice () [start .. end]) } } } impl < 'r > molecule :: prelude :: Reader < 'r > for UTF8StringVecReader < 'r > { type Entity = UTF8StringVec ; const NAME : & 'static str = "UTF8StringVecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { UTF8StringVecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let total_size = molecule :: unpack_number (slice) as usize ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } if slice_len == molecule :: NUMBER_SIZE { return Ok (()) ; } if slice_len < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE * 2 , slice_len) ; } let offset_first = molecule :: unpack_number (& slice [molecule :: NUMBER_SIZE ..]) as usize ; if offset_first % molecule :: NUMBER_SIZE != 0 || offset_first < molecule :: NUMBER_SIZE * 2 { return ve ! (Self , OffsetsNotMatch) ; } if slice_len < offset_first { return ve ! (Self , HeaderIsBroken , offset_first , slice_len) ; } let mut offsets : Vec < usize > = slice [molecule :: NUMBER_SIZE .. offset_first] . chunks_exact (molecule :: NUMBER_SIZE) . map (| x | molecule :: unpack_number (x) as usize) . collect () ; offsets . push (total_size) ; if offsets . windows (2) . any (| i | i [0] > i [1]) { return ve ! (Self , OffsetsNotMatch) ; } for pair in offsets . windows (2) { let start = pair [0] ; let end = pair [1] ; UTF8StringReader :: verify (& slice [start .. end] , compatible) ? ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct UTF8StringVecBuilder (pub (crate) Vec < UTF8String >) ; impl UTF8StringVecBuilder { pub fn set (mut self , v : Vec < UTF8String >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : UTF8String) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = UTF8String >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } pub fn replace (& mut self , index : usize , v : UTF8String) -> Option < UTF8String > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v)) } } impl molecule :: prelude :: Builder for UTF8StringVecBuilder { type Entity = UTF8StringVec ; const NAME : & 'static str = "UTF8StringVecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE * (self . 0 . len () + 1) + self . 0 . iter () . map (| inner | inner . as_slice () . len ()) . sum :: < usize > () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { let item_count = self . 0 . len () ; if item_count == 0 { writer . write_all (& molecule :: pack_number (molecule :: NUMBER_SIZE as molecule :: Number ,)) ? ; } else { let (total_size , offsets) = self . 0 . iter () . fold ((molecule :: NUMBER_SIZE * (item_count + 1) , Vec :: with_capacity (item_count) ,) , | (start , mut offsets) , inner | { offsets . push (start) ; (start + inner . as_slice () . len () , offsets) } ,) ; writer . write_all (& molecule :: pack_number (total_size as molecule :: Number)) ? ; for offset in offsets . into_iter () { writer . write_all (& molecule :: pack_number (offset as molecule :: Number)) ? ; } for inner in self . 0 . iter () { writer . write_all (inner . as_slice ()) ? ; } } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; UTF8StringVec :: new_unchecked (inner . into ()) } }
pub struct UTF8StringVecIterator (UTF8StringVec , usize , usize) ; impl :: core :: iter :: Iterator for UTF8StringVecIterator { type Item = UTF8String ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for UTF8StringVecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for UTF8StringVec { type Item = UTF8String ; type IntoIter = UTF8StringVecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; UTF8StringVecIterator (self , 0 , len) } } impl < 'r > UTF8StringVecReader < 'r > { pub fn iter < 't > (& 't self) -> UTF8StringVecReaderIterator < 't , 'r > { UTF8StringVecReaderIterator (& self , 0 , self . len ()) } } pub struct UTF8StringVecReaderIterator < 't , 'r > (& 't UTF8StringVecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for UTF8StringVecReaderIterator < 't , 'r > { type Item = UTF8StringReader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for UTF8StringVecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < UTF8String > for UTF8StringVec { fn from_iter < T : IntoIterator < Item = UTF8String >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } }
# [derive (Clone)] pub struct Uint8Vec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint8Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint8Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint8Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for Uint8Vec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint8Vec :: new_unchecked (v) } } impl Uint8Vec { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Uint8 > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Uint8 { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Uint8 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn as_reader < 'r > (& 'r self) -> Uint8VecReader < 'r > { Uint8VecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint8Vec { type Builder = Uint8VecBuilder ; const NAME : & 'static str = "Uint8Vec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint8Vec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint8VecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint8VecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct Uint8VecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint8VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint8VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint8VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > Uint8VecReader < 'r > { pub const ITEM_SIZE : usize = 1 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Uint8Reader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Uint8Reader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Uint8Reader :: new_unchecked (& self . as_slice () [start .. end]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint8VecReader < 'r > { type Entity = Uint8Vec ; const NAME : & 'static str = "Uint8VecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint8VecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct Uint8VecBuilder (pub (crate) Vec < Uint8 >) ; impl Uint8VecBuilder { pub const ITEM_SIZE : usize = 1 ; pub fn set (mut self , v : Vec < Uint8 >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : Uint8) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Uint8 >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } pub fn replace (& mut self , index : usize , v : Uint8) -> Option < Uint8 > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v)) } } impl molecule :: prelude :: Builder for Uint8VecBuilder { type Entity = Uint8Vec ; const NAME : & 'static str = "Uint8VecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint8Vec :: new_unchecked (inner . into ()) } }
pub struct Uint8VecIterator (Uint8Vec , usize , usize) ; impl :: core :: iter :: Iterator for Uint8VecIterator { type Item = Uint8 ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for Uint8VecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for Uint8Vec { type Item = Uint8 ; type IntoIter = Uint8VecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; Uint8VecIterator (self , 0 , len) } } impl < 'r > Uint8VecReader < 'r > { pub fn iter < 't > (& 't self) -> Uint8VecReaderIterator < 't , 'r > { Uint8VecReaderIterator (& self , 0 , self . len ()) } } pub struct Uint8VecReaderIterator < 't , 'r > (& 't Uint8VecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for Uint8VecReaderIterator < 't , 'r > { type Item = Uint8Reader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for Uint8VecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < Uint8 > for Uint8Vec { fn from_iter < T : IntoIterator < Item = Uint8 >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } }
# [derive (Clone)] pub struct Uint256Vec (molecule :: bytes :: Bytes) ; impl :: core :: fmt :: LowerHex for Uint256Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl :: core :: fmt :: Debug for Uint256Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl :: core :: fmt :: Display for Uint256Vec { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl :: core :: default :: Default for Uint256Vec { fn default () -> Self { let v = molecule :: bytes :: Bytes :: from_static (& Self :: DEFAULT_VALUE) ; Uint256Vec :: new_unchecked (v) } } impl Uint256Vec { const DEFAULT_VALUE : [u8 ; 4] = [0 , 0 , 0 , 0 ,] ; pub const ITEM_SIZE : usize = 32 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Uint256 > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Uint256 { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Uint256 :: new_unchecked (self . 0 . slice (start .. end)) } pub fn as_reader < 'r > (& 'r self) -> Uint256VecReader < 'r > { Uint256VecReader :: new_unchecked (self . as_slice ()) } } impl molecule :: prelude :: Entity for Uint256Vec { type Builder = Uint256VecBuilder ; const NAME : & 'static str = "Uint256Vec" ; fn new_unchecked (data : molecule :: bytes :: Bytes) -> Self { Uint256Vec (data) } fn as_bytes (& self) -> molecule :: bytes :: Bytes { self . 0 . clone () } fn as_slice (& self) -> & [u8] { & self . 0 [..] } fn from_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint256VecReader :: from_slice (slice) . map (| reader | reader . to_entity ()) } fn from_compatible_slice (slice : & [u8]) -> molecule :: error :: VerificationResult < Self > { Uint256VecReader :: from_compatible_slice (slice) . map (| reader | reader . to_entity ()) } fn new_builder () -> Self :: Builder { :: core :: default :: Default :: default () } fn as_builder (self) -> Self :: Builder { Self :: new_builder () . extend (self . into_iter ()) } }
# [derive (Clone , Copy)] pub struct Uint256VecReader < 'r > (& 'r [u8]) ; impl < 'r > :: core :: fmt :: LowerHex for Uint256VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { use molecule :: hex_string ; if f . alternate () { write ! (f , "0x") ? ; } write ! (f , "{}" , hex_string (self . as_slice ())) } } impl < 'r > :: core :: fmt :: Debug for Uint256VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{}({:#x})" , Self :: NAME , self) } } impl < 'r > :: core :: fmt :: Display for Uint256VecReader < 'r > { fn fmt (& self , f : & mut :: core :: fmt :: Formatter) -> :: core :: fmt :: Result { write ! (f , "{} [" , Self :: NAME) ? ; for i in 0 .. self . len () { if i == 0 { write ! (f , "{}" , self . get_unchecked (i)) ? ; } else { write ! (f , ", {}" , self . get_unchecked (i)) ? ; } } write ! (f , "]") } } impl < 'r > Uint256VecReader < 'r > { pub const ITEM_SIZE : usize = 32 ; pub fn total_size (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . item_count () } pub fn item_count (& self) -> usize { molecule :: unpack_number (self . as_slice ()) as usize } pub fn len (& self) -> usize { self . item_count () } pub fn is_empty (& self) -> bool { self . len () == 0 } pub fn get (& self , idx : usize) -> Option < Uint256Reader < 'r > > { if idx >= self . len () { None } else { Some (self . get_unchecked (idx)) } } pub fn get_unchecked (& self , idx : usize) -> Uint256Reader < 'r > { let start = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * idx ; let end = start + Self :: ITEM_SIZE ; Uint256Reader :: new_unchecked (& self . as_slice () [start .. end]) } } impl < 'r > molecule :: prelude :: Reader < 'r > for Uint256VecReader < 'r > { type Entity = Uint256Vec ; const NAME : & 'static str = "Uint256VecReader" ; fn to_entity (& self) -> Self :: Entity { Self :: Entity :: new_unchecked (self . as_slice () . to_owned () . into ()) } fn new_unchecked (slice : & 'r [u8]) -> Self { Uint256VecReader (slice) } fn as_slice (& self) -> & 'r [u8] { self . 0 } fn verify (slice : & [u8] , _compatible : bool) -> molecule :: error :: VerificationResult < () > { use molecule :: verification_error as ve ; let slice_len = slice . len () ; if slice_len < molecule :: NUMBER_SIZE { return ve ! (Self , HeaderIsBroken , molecule :: NUMBER_SIZE , slice_len) ; } let item_count = molecule :: unpack_number (slice) as usize ; if item_count == 0 { if slice_len != molecule :: NUMBER_SIZE { return ve ! (Self , TotalSizeNotMatch , molecule :: NUMBER_SIZE , slice_len) ; } return Ok (()) ; } let total_size = molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * item_count ; if slice_len != total_size { return ve ! (Self , TotalSizeNotMatch , total_size , slice_len) ; } Ok (()) } }
# [derive (Clone , Debug , Default)] pub struct Uint256VecBuilder (pub (crate) Vec < Uint256 >) ; impl Uint256VecBuilder { pub const ITEM_SIZE : usize = 32 ; pub fn set (mut self , v : Vec < Uint256 >) -> Self { self . 0 = v ; self } pub fn push (mut self , v : Uint256) -> Self { self . 0 . push (v) ; self } pub fn extend < T : :: core :: iter :: IntoIterator < Item = Uint256 >> (mut self , iter : T) -> Self { for elem in iter { self . 0 . push (elem) ; } self } pub fn replace (& mut self , index : usize , v : Uint256) -> Option < Uint256 > { self . 0 . get_mut (index) . map (| item | :: core :: mem :: replace (item , v)) } } impl molecule :: prelude :: Builder for Uint256VecBuilder { type Entity = Uint256Vec ; const NAME : & 'static str = "Uint256VecBuilder" ; fn expected_length (& self) -> usize { molecule :: NUMBER_SIZE + Self :: ITEM_SIZE * self . 0 . len () } fn write < W : molecule :: io :: Write > (& self , writer : & mut W) -> molecule :: io :: Result < () > { writer . write_all (& molecule :: pack_number (self . 0 . len () as molecule :: Number)) ? ; for inner in & self . 0 [..] { writer . write_all (inner . as_slice ()) ? ; } Ok (()) } fn build (& self) -> Self :: Entity { let mut inner = Vec :: with_capacity (self . expected_length ()) ; self . write (& mut inner) . unwrap_or_else (| _ | panic ! ("{} build should be ok" , Self :: NAME)) ; Uint256Vec :: new_unchecked (inner . into ()) } }
pub struct Uint256VecIterator (Uint256Vec , usize , usize) ; impl :: core :: iter :: Iterator for Uint256VecIterator { type Item = Uint256 ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl :: core :: iter :: ExactSizeIterator for Uint256VecIterator { fn len (& self) -> usize { self . 2 - self . 1 } } impl :: core :: iter :: IntoIterator for Uint256Vec { type Item = Uint256 ; type IntoIter = Uint256VecIterator ; fn into_iter (self) -> Self :: IntoIter { let len = self . len () ; Uint256VecIterator (self , 0 , len) } } impl < 'r > Uint256VecReader < 'r > { pub fn iter < 't > (& 't self) -> Uint256VecReaderIterator < 't , 'r > { Uint256VecReaderIterator (& self , 0 , self . len ()) } } pub struct Uint256VecReaderIterator < 't , 'r > (& 't Uint256VecReader < 'r > , usize , usize) ; impl < 't : 'r , 'r > :: core :: iter :: Iterator for Uint256VecReaderIterator < 't , 'r > { type Item = Uint256Reader < 't > ; fn next (& mut self) -> Option < Self :: Item > { if self . 1 >= self . 2 { None } else { let ret = self . 0 . get_unchecked (self . 1) ; self . 1 += 1 ; Some (ret) } } } impl < 't : 'r , 'r > :: core :: iter :: ExactSizeIterator for Uint256VecReaderIterator < 't , 'r > { fn len (& self) -> usize { self . 2 - self . 1 } }
impl :: core :: iter :: FromIterator < Uint256 > for Uint256Vec { fn from_iter < T : IntoIterator < Item = Uint256 >> (iter : T) -> Self { Self :: new_builder () . extend (iter) . build () } }
